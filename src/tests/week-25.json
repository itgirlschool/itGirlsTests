{
  "id": "week-25",
  "title": "Жизненный цикл компонента",
  "questions": [
    {
      "options": [
        {
          "title": "Да, так можно сделать",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "Нет, не получится",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "Да, только нужно указать this.props.title и this.props.description ",
          "isValid": false,
          "comment": "Больше не нужно указывать this.props, так как в данном примере реализована деструктуризация пропсов "
        }
      ],
      "type": "solo",
      "title": "В компонент передаются атрибуты ‘description’ и ‘title’. Могу ли я их сложить, как в примере, чтобы получить одну строку и вывести в компоненте?",
      "image": 0
    },
    {
      "options": [
        {
          "title": "componentDidMount()",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "shouldComponentUpdate()",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "componentDidUpdate()",
          "isValid": true,
          "comment": "Верно! Он принимает предыдущее состояние prevProps и будущее состояние nextProps и сравнивает их"
        }
      ],
      "type": "solo",
      "title": "С помощью какого метода можно отловить изменения ‘props’?",
      "image": null
    },
    {
      "options": [
        {
          "title": "firstObj является ссылкой на initialObj, а secondObj - это новый объект, скопированный с initialObj",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "При изменении свойств secondObj они также поменяются и у initialObj",
          "isValid": false,
          "comment": "secondObj - это новый объект со своими свойствами"
        },
        {
          "title": "При изменении свойств secondObj они не поменяются у initialObj",
          "isValid": true,
          "comment": "Верно! Это новый объект со своими свойствами"
        }
      ],
      "type": "multi",
      "title": "Оператор расширения часто используется также для клонирования объекта. Чем отличаются эти две записи, и какую проблему решает здесь оператор расширения?",
      "image": 1
    },
    {
      "options": [
        {
          "title": "componentWillUnmount() при размонтировании компонента",
          "isValid": false,
          "comment": "В этом методе выполняется необходимый сброс: отмена подписок и сетевых запросов, таймеров и др."
        },
        {
          "title": "componentDidMount() при монтировании компонента",
          "isValid": true,
          "comment": "Верно! Этот метод вызывается один в жизненном цикле сразу после монтирования компонента. Перед ним выполняется рендер."
        },
        {
          "title": "shouldComponentUpdate() при обновлении компонента",
          "isValid": false,
          "comment": "На этом этапе жизненного цикла данные компонента обновляются в ответ на пользовательские события. Происходит повторный рендер"
        }
      ],
      "type": "solo",
      "title": "В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы?",
      "image": null
    },
    {
      "options": [
        {
          "title": "getSnapshotBeforeUpdate()",
          "isValid": false,
          "comment": "Этот метод вызывается перед последним рендером компонента. Это позволяет получить информацию о модели  DOM до того, как она будет изменена"
        },
        {
          "title": "componentDidUpdate()",
          "isValid": false,
          "comment": "Этот метод вызывается сразу после обновления компонента (если shouldComponentUpdate возвращает true). В качестве параметров передаются старые значения объектов state и props."
        },
        {
          "title": "componentDidCatch()",
          "isValid": true,
          "comment": "Верно! Этот метод даёт возможность разработчику отловить и залогировать ошибки"
        }
      ],
      "type": "solo",
      "title": "С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?",
      "image": null
    },
    {
      "options": [
        {
          "title": "В нём устанавливается метод render() для отрисовки jsx-компонента на странице",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "В нём устанавливается состояние (state) и свойства (props), осуществляется привязка обработчиков событий к экземпляру",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "В нём осуществляется export необходимых компонентов",
          "isValid": false,
          "comment": ""
        }
      ],
      "type": "solo",
      "title": "Какой код обычно пишут в конструкторе? Для каких задач он используется?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Осуществляет размонтирование компонента",
          "isValid": false,
          "comment": "Размонтирование происходит в методе жизненного цикла componentWillUnmount()"
        },
        {
          "title": "Создаёт дочерние элементы компонента",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "Отвечает за отображение компонента при монтировании и при изменении состояния",
          "isValid": true,
          "comment": "Верно! Это единственный обязательный метод в классовом компоненте. Функция render() должна быть чистой: не изменять состояние компонента, всегда возвращать один и тот же результат, не взаимодействовать напрямую с браузером"
        }
      ],
      "type": "solo",
      "title": "Что делает функция ‘render()’?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Изменения state",
          "isValid": true,
          "comment": "Верно! При изменении состояния компонента, его необходимо перерисовать"
        },
        {
          "title": "Вызов метода forceUpdate()",
          "isValid": true,
          "comment": "Верно! Вызов forceUpdate() принудительно повторно отрисовывает  компонент, пропуская метод shouldComponentUpdate()"
        },
        {
          "title": "Перехват ошибки",
          "isValid": true,
          "comment": "Верно! При возникновении ошибки необходимо уведомить об этом пользователя, перерисовав компонент"
        },
        {
          "title": "Перерисовка родительского компонента",
          "isValid": true,
          "comment": "Верно! При изменении родительского компонента происходит проверка, затронули ли изменения дочерний элемент "
        }
      ],
      "type": "multi",
      "title": "Что может вызвать ‘render()’ компонента?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Определить значения по умолчанию с помощью defaultProps: class Timer extends React.Component {\n    static defaultProps = { minutes: 0,\n        seconds: 0};\n    constructor(props) {\n        super(props);\n        this.state = {\n            minutes: this.props.minutes,\n            seconds: this.props.seconds\n        }:\n    }\n",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "Нужно задать начальные значения в самом объекте с пропсами: class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        const {minutes: 0, seconds: 0} = this.props\n    }\n}",
          "isValid": false,
          "comment": ""
        }
      ],
      "type": "solo",
      "title": "Что нужно изменить в коде из урока (на видео), чтобы начальные параметры компонента приходили из пропсов, но, если пропсы вообще не заданы, начальные значения были инициализированы нулями?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Нет, это обязательное условие применения useEffect",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "Можно, функция выполнится только один раз после монтирования",
          "isValid": false,
          "comment": "Это произойдет, если второй аргумент всё-таки передаётся, но это пустой массив"
        },
        {
          "title": "Можно, эффект будет запускать при каждом обновлении компонента",
          "isValid": true,
          "comment": "Верно! По умолчанию useEffect запускается как после первого рендера, так и после каждого обновления"
        }
      ],
      "type": "solo",
      "title": "Можно ли не передавать второй аргумент в хук ‘useEffect’, и что тогда произойдет?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Нет, это приведет к переполнению стека",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "Да, можно использовать столько раз, сколько нужно",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "Можно, но только при обязательном указании параметров, при изменении которых вызывается функция эффекта",
          "isValid": false,
          "comment": "Массив с параметрами не обязательно указывать внутри useEffect, тогда эффект будет запускать при каждом обновлении. \nЕсли передать пустой массив в качестве второго аргумента, эффект запуститься и очиститься только один раз"
        }
      ],
      "type": "solo",
      "title": "Можно ли несколько раз использовать хук ‘useEffect’ внутри одного компонента?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Функция вызовется только один раз перед размонтированием компонента",
          "isValid": true,
          "comment": "Верно! Если эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект"
        },
        {
          "title": "Повторный вызов эффекта",
          "isValid": false,
          "comment": "Очередной вызов эффекта происходит при изменении переданных в качестве второго аргумента параметров"
        },
        {
          "title": "Вызов новой функции",
          "isValid": false,
          "comment": ""
        }
      ],
      "type": "solo",
      "title": "Что означает возвращение функции в теле эффекта?",
      "image": null
    },
    {
      "options": [
        {
          "title": "Нет, потому что в скобках не указаны дочерние элементы, которые должны быть перерисованы",
          "isValid": false,
          "comment": ""
        },
        {
          "title": "Да, так как произойдёт перерендер компонента, а с ним - и дочерних элементов",
          "isValid": true,
          "comment": ""
        },
        {
          "title": "Нет, так как рендер дочерних элементов не зависит от родительского компонента",
          "isValid": false,
          "comment": ""
        }
      ],
      "type": "solo",
      "title": "Будут ли перерисованы дочерние элементы компонента при вызове метода ‘forceUpdate()’?",
      "image": null
    }
  ]
}